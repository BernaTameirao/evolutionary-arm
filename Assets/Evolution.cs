using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System.Diagnostics;

public class Evolution : MonoBehaviour
{   
    //the pathFinding script
    private PathFinding astarScript;
    //private DStarPathFinding dstarScript;
    //the grid script
    private Gridi gridScript;
    //the mutation rate
    private int mutRate = 1;
    //the path generated by the a* that will be used as goals
    private Queue<Node> pathQueue;
    //stopwatch to record the time elapsed during the simulation
    private Stopwatch sw;
    //the filename where the experiment results will be stored in the case of a limited amount of generations
    public string fileName = "experimentLog";
    //the streamWriter to save the log
    private StreamWriter logFile;
    //robot is the whole sctructure created by createScene beggining by the robot's base
    public GameObject robot;
    //the gameobject working as the objective, its 3d position is changed and used for the fitness calculations
    public GameObject goal;
    //this is a list containing the robot's current angles
    private List<Vector3> robotState = new List<Vector3>();
    //this is the population, all the possible solutions for the problem
    private List<List<Vector3>> popStates = new List<List<Vector3>>();

    private CreateScene SceneScript;
    // Evolution parameters

    //N is the number of joints
    private int N = 0;
    //how many individuals in the same population, to be determined by each experiment configuration
    public int popSize;
    //the maximum possible change in a joint's angulation, the lower the more of a robotic like movement
    public float maxStep;
    //a variable to mark what the current generation is
    private int generation = 1;
    //not used at the moment, its future use will be the speed to change between each point of the path found as the goal
    public int generationsPerObjective = 20;
    //how many generations will be calculated for the experiment, -1 means undefined or neverending simulation
    public int maxGenerations = -1;
    // List of arm parts from CreateScene
    private GameObject[,] armParts;
    //this segmentLength should match distJoint in createScene, as it does in the awake method
    private float segmentLength = 0.4f;
    //just a variable to determine if an individual is better or worse than the previous best one
    private float previousBestfitness;
    public List<GameObject> obstaclesList = new List<GameObject>();
    public List<GameObject> obstaclesListFound = new List<GameObject>();

    public int whichFitness = 1;

    private MainUIController UIScript;
    private float[] totalSumDistanceDestination = new float[8000];
    private float[] totalSumDistanceObstacleReal = new float[8000];
    private float[] totalSumDistanceObstacleRobot = new float[8000];
    private Vector3 finalPosition;
    //private float[,] differenceAngles = new float[9, 2300];
    private List<Vector3> previousRobotState = new List<Vector3>();

    //Mudança Fog of War
    private RobotGrid robotGridScript;
    public bool isShowingFog = false;

    public void Awake(){
        //gets the relevant infos from the createscene and pathFinding script
        SceneScript = GetComponent<CreateScene>();
        N = SceneScript.N;
        segmentLength = SceneScript.distJoints;
        armParts = SceneScript.spawnedObjects;
        astarScript = GetComponent<PathFinding>();
        gridScript = GetComponent<Gridi>();
        UIScript = GetComponent<MainUIController>();
        robotGridScript = GetComponent<RobotGrid>();

        
        generation = 1;
        //start to write into the file
        if(maxGenerations != -1 && sw == null) {
            sw = new Stopwatch();   
            logFile = new StreamWriter(fileName, false);
        }

        popStates.Clear();
        robotState.Clear();

        //initialize the lists with a 0 angulation
        for (int i = 0; i < N; i++){
            robotState.Add(new Vector3(0, 0, 0));
            previousRobotState.Add(new Vector3(0, 0, 0));
        }
        //iniitialize a random population
        for(int i=0; i<popSize; i++){
            popStates.Add(new List<Vector3>());
            for (int j= 0; j < N; j++){
                float angleX = Random.Range(-maxStep + robotState[j].x, maxStep + robotState[j].x);
                float angleY = Random.Range(-maxStep + robotState[j].y, maxStep + robotState[j].y);
                float angleZ = Random.Range(-maxStep + robotState[j].z, maxStep + robotState[j].z);
                popStates[i].Add(new Vector3(angleX, angleY, angleZ));
            }
        }
        //disables the script to wait for the pathFinding algorithm to do its job
        this.enabled = false;
    }

    private void Start(){

        segmentLength = SceneScript.distJoints;
        armParts = SceneScript.spawnedObjects;
    }

    /// <summary>
    /// Creates a queue matching the a* path created.
    private void createPathQueue() {
        //gets the path found by the a* algorithm and enqueue them into the queue
        pathQueue = new Queue<Node>();
        List<Node> aux = astarScript.answerPath();
        //List<Node> aux = dstarScript.GetPath();
        aux.ForEach(pathQueue.Enqueue);
        //already sets the goal as the first element of the path
        goal.transform.position = pathQueue.Dequeue().worldPosition;

    }

    /// <summary>
    /// Activates the Update method allowing it to happen, used by the PathFinding script to start the evolution script
    public void activate() {
        this.enabled = true;
        finalPosition = goal.transform.position;
        createPathQueue();

    }

    /// <summary>
    /// The never ending loop of evaluating a population, displaying the best configuration and generating a new population based on the previous best one
    void Update(){

        // if this happens, it means it's time to use the next point in the path as the goal and so I update the goal
        if(Vector3.Distance(simulatedArm(robotState), goal.transform.position) < 0.07f) {
            if(pathQueue.Count != 0) {
                Node aux = pathQueue.Dequeue();
                goal.transform.position = aux.worldPosition;
            }
        }

        // Defines the fitness function that will be used.
        switch(whichFitness){
            case 1:
                fitnessEvaluation2();
                break;

            case 2:
                fitnessEvaluation();
                break;

            case 3:
                fitnessEvaluation3();
                break;

            case 4:
                fitnessEvaluation4();
                break;

            case 5:
                fitnessEvaluation5();
                    break;

            default:
                break;
        }

        // Collects the distance to the goal and the distance to the closest obstacle.
        if(UIScript.isCollectingData){
            totalSumDistanceDestination[generation-1] += Vector3.Distance(finalPosition, simulatedArm(robotState));
            totalSumDistanceObstacleRobot[generation-1] += distanceObstacles(robotState);
            totalSumDistanceObstacleReal[generation-1] += (float)((gridScript.layers - closestNodeToObstacle(robotState).layer) * gridScript.nodeDiameter);
        }

        updateObject();
        newPopulation();
        checkObstacles();

        // Check for unseen obstacles if fog of war is active.
        if(isShowingFog){
            checkHiddenObstacles();
        }

        //prints the generation and best fitness, i intend to make this to be written into a text file for another program to read and plot
        if(maxGenerations != -1) {
            //makes the update method stop when a certain number of generations is reached
            //logFile.WriteLine(generation + ", " + previousBestfitness + ", " + distanceObstacles(robotState));
            if(generation >= maxGenerations) {
                //writes data to the file and closes it
                if(UIScript.isCollectingData && UIScript.getSimulationCounter() < 49){

                    this.enabled = false;
                    UIScript.setSimulationCounter(-1);
                    UIScript.resetSimulationWithObstacles();

                } else{

                    for(int counter=0; counter<8000; counter++){

                        totalSumDistanceDestination[counter] /= 50;
                        totalSumDistanceObstacleReal[counter] /= 50;
                        totalSumDistanceObstacleRobot[counter] /= 50;

                        logFile.WriteLine(totalSumDistanceDestination[counter] + ". " + totalSumDistanceObstacleReal[counter] + ". "+ 
                                        totalSumDistanceObstacleRobot[counter] +". " + counter + ". " + whichFitness);
                        
                    }
                    
                    logFile.Flush();

                    totalSumDistanceDestination = new float[8000];
                    totalSumDistanceObstacleReal = new float[8000];
                    totalSumDistanceObstacleRobot = new float[8000];

                    whichFitness +=1;

                    if (whichFitness>3){
                        endProgram();
                    }

                    UIScript.setSimulationCounter(0);
                    this.enabled = false;
                    UIScript.resetSimulationWithObstacles();
                }
            }
        }
        generation++;
    }

    /// <summary>
    /// Update the position of the robotic arm on the environment.
    public void updateObject(){

        Quaternion rotation = Quaternion.identity;
        Vector3 position = robot.transform.GetChild(0).position; // base of first segment

        for(int counter=0; counter<N; counter++){

            // Get the joint rotation (Euler -> Quaternion)
            Quaternion jointRotation = Quaternion.Euler(robotState[counter]);

            // Accumulate the rotation
            rotation *= jointRotation;

            // Set the segment's position and rotation
            armParts[0, counter].transform.position = position;
            armParts[0, counter].transform.rotation = rotation;

            // Compute the position of the next segment's base
            position += rotation * Vector3.up * segmentLength;
        }

        // Set the end effector sphere (at the end of the last segment)
        armParts[2, 0].transform.position = position;

        // Save the current state for future comparison
        previousRobotState = SceneScript.DeepCopy(robotState);
    }

    /// <summary>
    /// Add an obstacle to the list.
    /// <parameters>
    /// obj (GameObject): the object.
    public void addObstacle(GameObject obj) {
        obj.transform.hasChanged = false;
        obstaclesList.Add(obj);

    }

    /// <summary>
    /// Deactivates every obstacle and clear the lists.
    public void clearObstacles()
    {   
        // Deactivates every obstacle
        foreach (var obstacle in obstaclesList)
        {
            if (obstacle != null)
            {   
                obstacle.GetComponent<Renderer>().material.color = Color.white;
                obstacle.SetActive(false);
            }
        }
        obstaclesList.Clear();
        obstaclesListFound.Clear();
    }
    
    /// <summary>
    /// Checks if an obstacle has moved and remakes the grid
    void checkObstacles() {
        foreach(GameObject obstacle in obstaclesList) {
            // If the position of an object has changed and it stopped moving
            if (obstacle.transform.hasChanged == true) {
                if(obstacle.GetComponent<CheckMovement>().isMoving == false) {
                    // Recreates the main grid
                    gridScript.RecreateGrid(obstacle);

                    // If fog of war is activated and the obstacle has been found, recreates the secondary grid
                    if(obstaclesListFound.Contains(obstacle)){
                        robotGridScript.RecreateGrid(obstacle);
                    }

                    obstacle.transform.hasChanged = false;
                }
            }
        }
    }

    /// <summary>
    /// Checks for obstacles, that are close to the manipulator and hidden on the secondary grid.
    void checkHiddenObstacles(){
        
        // Gets the closest node
        Node closestNode = closestNodeToObstacle(robotState);

        // If the manipulator touches that node
        if(closestNode!=null && gridScript.layers - closestNode.layer <= 0){
            
            // Gets the collider of any obstacle in that node
            Collider[] colliders = Physics.OverlapSphere(closestNode.worldPosition, gridScript.nodeDiameter, gridScript.unwalkableMask);
            foreach (Collider col in colliders){
                
                // If the obstacle has not been found
                if(!obstaclesListFound.Contains(col.gameObject)){
                    
                    List<Vector3> auxList = new List<Vector3>();
                    foreach (Node n in pathQueue){
                        auxList.Add(new Vector3(n.gridX, n.gridY, n.gridZ));
                    }

                    // Updates the found obstacles list, and the secondary grid.
                    obstaclesListFound.Add(col.gameObject);
                    robotGridScript.AddObstacleToGrid(col.gameObject);

                    // Changes the obstacle color to red, to show it has been found.
                    col.gameObject.GetComponent<Renderer>().material.color = Color.red;

                    // If the new obstacle is blocking the a* path, recreates the path.
                    Node[,,] auxGrid = robotGridScript.grid;
                    foreach (Vector3 n in auxList){

                        if(!auxGrid[(int)n.x, (int)n.y, (int)n.z].walkable){
                            
                            Node currentNode = robotGridScript.NodeFromWorldPoint(goal.transform.position);
                            int index = robotGridScript.path.FindIndex(n => n.worldPosition == currentNode.worldPosition);

                            Node newNode = currentNode;
                            while(!newNode.walkable){

                                index -= 1;
                                Node auxNode = robotGridScript.path[index];
                                newNode = auxGrid[auxNode.gridX, auxNode.gridY, auxNode.gridZ];
                            }
                            astarScript.ChangePath(newNode.worldPosition);
                            break;
                        }
                    }
                }
            }
        }
    }

    /// <summary>
    /// Function that writes the general configurations into the file, but only after everything was collected.
    void endProgram() {
        sw.Stop();
        logFile.WriteLine("/------------------------------------------------/");
        logFile.WriteLine("Time elapsed(ms): " + sw.ElapsedMilliseconds);
        logFile.WriteLine("Generations: " + maxGenerations);
        logFile.WriteLine("Number of joints: " + N);
        logFile.WriteLine("Population size: " + popSize);
        logFile.WriteLine("MaxStep: " + maxStep);
        logFile.WriteLine("Segment length: " + segmentLength);
        logFile.Dispose();
        Application.Quit();
        this.enabled = false;
    }

    /// <summary>
    /// Conservative fitness function. Prioritizes the non-colision with obstacles more than reach the final goal. 
    void fitnessEvaluation() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float bestFitness = Mathf.Min(1/Vector3.Distance(simulatedArm(robotState), goal.transform.position), 10/SceneScript.distJoints) - 1/Mathf.Pow(distanceObstacles(robotState), 2); //a if that doesnt require the square root to be calculated
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            //calculated the fitness, or distance to the goal
            
            float fitness = Mathf.Min(1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position), 10/SceneScript.distJoints) - 1/Mathf.Pow(distanceObstacles(popStates[i]), 2);

            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    /// <summary>
    /// Aggressive fitness function. Prioritizes reaching the goal more than making sure the avoiding of obstacles.
    void fitnessEvaluation2() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float auxObstacles = distanceObstacles(robotState);
        float bestFitness = 1/Vector3.Distance(simulatedArm(robotState), goal.transform.position) + 1*(auxObstacles <= 0 ? -Mathf.Infinity : auxObstacles);
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            //calculated the fitness, or distance to the goal
            auxObstacles = distanceObstacles(popStates[i]);
            float fitness = 1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position) + 1*(auxObstacles <= 0 ? -Mathf.Infinity : auxObstacles);
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    /// <summary>
    /// Moderate fitness function. Gives similar importance to both tasks.
    void fitnessEvaluation3() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        float bestFitness = -Vector3.Distance(simulatedArm(robotState), goal.transform.position) + distanceObstacles(robotState);

        for (int i = 0; i < popSize; i++){
            float fitness = -Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position) + distanceObstacles(popStates[i]);
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    void fitnessEvaluation4() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float auxObstacles = distanceObstacles(robotState);
        float bestFitness = 1/(1 + Vector3.Distance(simulatedArm(robotState), goal.transform.position)) - 3* Mathf.Max(0, 0.04f - auxObstacles);
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            //calculated the fitness, or distance to the goal
            auxObstacles = distanceObstacles(popStates[i]);
            float fitness = 1/(1 + Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position)) - 3* Mathf.Max(0, 0.04f - auxObstacles);
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    void fitnessEvaluation5() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float auxObstacles = distanceObstacles(robotState);
        float bestFitness = 1/(1 + Vector3.Distance(simulatedArm(robotState), goal.transform.position)) - 2* Mathf.Max(0, 0.06f - auxObstacles);
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            //calculated the fitness, or distance to the goal
            auxObstacles = distanceObstacles(popStates[i]);
            float fitness = 1/(1 + Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position)) - 2* Mathf.Max(0, 0.06f - auxObstacles);
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    /// <summary>
    /// Gets the distance from the closest obstacle on the secondary grid.
    float distanceObstaclesFromPointRobot(Vector3 point) {
        Node place = robotGridScript.NodeFromWorldPoint(point);

        return (gridScript.layers - place.layer) * gridScript.nodeDiameter;
    }

    /// <summary>
    /// Gets the distance from the closest obstacle on the main grid.
    float distanceObstaclesFromPoint(Vector3 point) {
        Node place = gridScript.NodeFromWorldPoint(point);

        return (gridScript.layers - place.layer) * gridScript.nodeDiameter;
    }

    float distanceObstacles(List<Vector3> angles) {
        
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;
        //the distance will be the minimum distance to an obstacle
        float distance = 999999;
        for (int j = 0; j < N; j++) {

            Quaternion jointRotation = Quaternion.Euler(angles[j]);

            // Update the cumulative rotation (parent-to-child)
            rotation *= jointRotation;
            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis

            float minDistanceCurrentJoint;
  
            if(isShowingFog){

                minDistanceCurrentJoint = distanceObstaclesFromPointRobot(position);
            } else {

                minDistanceCurrentJoint = distanceObstaclesFromPoint(position);
            }

            //compares to see if it is any smaller than the closest distance yet
            distance = Mathf.Min(minDistanceCurrentJoint, distance);
        }

        return distance;
    }

    //Mudança Fog of War
    Node closestNodeToObstacle(List<Vector3> angles) {
        if(obstaclesList.Count == 0) return null; //a 0 value means no obstacle exists and thus it shouldn't be considered
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;
        //the distance will be the minimum distance to an obstacle
        float distance = 999999;
        Node closestNode = null;
        for (int j = 0; j < N; j++) {

            Quaternion jointRotation = Quaternion.Euler(angles[j]);

            // Update the cumulative rotation (parent-to-child)
            rotation *= jointRotation;
            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis
            float minDistanceCurrentJoint = distanceObstaclesFromPoint(position);

            //compares to see if it is any smaller than the closest distance yet
            if(distance >= minDistanceCurrentJoint){

                distance = minDistanceCurrentJoint;
                closestNode = gridScript.NodeFromWorldPoint(position);
            }
        }

        return closestNode;
    }

    /// <summary>
    /// Does the math to calculate the end position given a set of angles
    /// <parameters>
    /// evaluated (List<Vector3>) The set of angles of each segment of the robotic arm.
    Vector3 simulatedArm(List<Vector3> evaluated) {
        //the position starts at the base position
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;
    
        for (int j = 0; j < N; j++) {

            Quaternion jointRotation = Quaternion.Euler(evaluated[j]);

            // Update the cumulative rotation (parent-to-child)
            rotation *= jointRotation;

            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis
        }

        // Return the calculated end effector position
        return position;
    }

    /// <summary>
    /// Generates a new population.
    void newPopulation(){

        if(generation % 100 == 0) {
            mutRate = Mathf.Max((mutRate + 1) % N, 1);//the mutation keeps changing every 100 generations and it means the number of joint that are gonna be changed
        }
        for (int i = 0; i < popSize; i++){
            for (int j = 0; j < mutRate; j++){
                int idx = Random.Range(0, N);//a random index is generated
                float angleX = Random.Range(-maxStep + robotState[idx].x, maxStep + robotState[idx].x);
                float angleY = Random.Range(-maxStep + robotState[idx].y, maxStep + robotState[idx].y);
                float angleZ = Random.Range(-maxStep + robotState[idx].z, maxStep + robotState[idx].z);
                popStates[i][idx] = new Vector3(angleX, angleY, angleZ);
            }
        }
    }

    /// <summary>
    /// Gets the data that will be sent to UI.
    /// <returns>
    /// The data (float[])
    public float[] getUIData() {

        float elapsedMilliseconds = (sw != null) ? (float)sw.ElapsedMilliseconds : -1;
        float goalDist = (finalPosition != null) ? (Vector3.Distance(finalPosition, simulatedArm(robotState))) : -1;
        float realObstDist = ((gridScript.layers - closestNodeToObstacle(robotState).layer) * gridScript.nodeDiameter);
        float perceptionObstDist = distanceObstacles(robotState);

        return new float[]
        {
            elapsedMilliseconds, 
            (float)maxGenerations, 
            (float)N, 
            (float)popSize, 
            maxStep, 
            segmentLength,
            goalDist,
            realObstDist,
            perceptionObstDist
        };
    }

    /// <summary>
    /// Sets the fog of war enabledness.
    /// <parameters>
    /// value (bool): the value.
    public void setFogOfWar(bool value){

        isShowingFog = value;
    }
}