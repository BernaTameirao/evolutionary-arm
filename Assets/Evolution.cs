using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System.Diagnostics;

public class Evolution : MonoBehaviour
{   
    //the pathFinding script
    private PathFinding astarScript;
    //private DStarPathFinding dstarScript;
    //the grid script
    private Gridi gridScript;
    //the mutation rate
    private int mutRate = 1;
    //the path generated by the a* that will be used as goals
    private Queue<Node> pathQueue;
    //stopwatch to record the time elapsed during the simulation
    private Stopwatch sw;
    //the filename where the experiment results will be stored in the case of a limited amount of generations
    public string fileName = "experimentLog";
    //the streamWriter to save the log
    private StreamWriter logFile;
    //robot is the whole sctructure created by createScene beggining by the robot's base
    public GameObject robot;
    //the gameobject working as the objective, its 3d position is changed and used for the fitness calculations
    public GameObject goal;
    //this is a list containing the robot's current angles
    private List<Vector3> robotState = new List<Vector3>();
    //this is the population, all the possible solutions for the problem
    private List<List<Vector3>> popStates = new List<List<Vector3>>();

    private CreateScene SceneScript;
    // Evolution parameters

    //N is the number of joints
    private int N = 0;
    //how many individuals in the same population, to be determined by each experiment configuration
    public int popSize;
    //the maximum possible change in a joint's angulation, the lower the more of a robotic like movement
    public float maxStep;
    //a variable to mark what the current generation is
    private int generation = 1;
    //not used at the moment, its future use will be the speed to change between each point of the path found as the goal
    public int generationsPerObjective = 20;
    //how many generations will be calculated for the experiment, -1 means undefined or neverending simulation
    public int maxGenerations = -1;
    // List of arm parts from CreateScene
    private GameObject[,] armParts;
    //this segmentLength should match distJoint in createScene, as it does in the awake method
    private float segmentLength = 0.4f;
    //just a variable to determine if an individual is better or worse than the previous best one
    private float previousBestfitness;
    public List<GameObject> obstaclesList = new List<GameObject>();
    public List<GameObject> obstaclesListFound = new List<GameObject>();

    public int whichFitness = 1;

    private MainUIController UIScript;
    private float[] totalSumDistanceDestination = new float[2300];
    private float[] totalSumDistanceObstacleReal = new float[2300];
    private float[] totalSumDistanceObstacleRobot = new float[2300];
    private Transform finalPosition;
    //private float[,] differenceAngles = new float[9, 2300];
    private List<Vector3> previousRobotState = new List<Vector3>();

    //Mudança Fog of War
    private RobotGrid robotGridScript;
    public bool isShowingFog = true;

    public void Awake(){
        //gets the relevant infos from the createscene and pathFinding script
        SceneScript = GetComponent<CreateScene>();
        N = SceneScript.N;
        segmentLength = SceneScript.distJoints;
        armParts = SceneScript.spawnedObjects;
        astarScript = GetComponent<PathFinding>();
        //dstarScript = GetComponent<DStarPathFinding>();
        gridScript = GetComponent<Gridi>();
        UIScript = GetComponent<MainUIController>();

        //Mudança Fog of War
        robotGridScript = GetComponent<RobotGrid>();
        
        generation = 1;
        //start to write into the file
        if(maxGenerations != -1 && sw == null) {
            sw = new Stopwatch();   
            logFile = new StreamWriter(fileName, false);
        }

        popStates.Clear();
        robotState.Clear();

        //initialize the lists with a 0 angulation
        for (int i = 0; i < N; i++){
            robotState.Add(new Vector3(0, 0, 0));
            previousRobotState.Add(new Vector3(0, 0, 0));
        }
        //iniitialize a random population
        for(int i=0; i<popSize; i++){
            popStates.Add(new List<Vector3>());
            for (int j= 0; j < N; j++){
                float angleX = Random.Range(-maxStep + robotState[j].x, maxStep + robotState[j].x);
                float angleY = Random.Range(-maxStep + robotState[j].y, maxStep + robotState[j].y);
                float angleZ = Random.Range(-maxStep + robotState[j].z, maxStep + robotState[j].z);
                popStates[i].Add(new Vector3(angleX, angleY, angleZ));
            }
        }
        //disables the script to wait for the pathFinding algorithm to do its job
        this.enabled = false;
    }

    private void Start(){

        segmentLength = SceneScript.distJoints;
        armParts = SceneScript.spawnedObjects;
    }

    private void createPathQueue() {
        //gets the path found by the a* algorithm and enqueue them into the queue
        pathQueue = new Queue<Node>();
        List<Node> aux = astarScript.answerPath();
        //List<Node> aux = dstarScript.GetPath();
        aux.ForEach(pathQueue.Enqueue);
        //already sets the goal as the first element of the path
        goal.transform.position = pathQueue.Dequeue().worldPosition;

    }

    //activates the Update method allowing it to happen, used by the PathFinding script to start the evolution script
    public void activate() {
        this.enabled = true;
        finalPosition = goal.transform;
        createPathQueue();
        //starts the time count
        /*if(maxGenerations != -1)
            sw.Start();*/
    }
    //the never ending loop of evaluating a population, displaying the best configuration and generating a new population based on the previous best one
    void Update(){
        //if this happens, it means it's time to use the next point in the path as the goal and so I update the goal
        /*if(generation % generationsPerObjective == 0) {
            if(pathQueue.Count != 0) {
                Node aux = pathQueue.Dequeue();
                goal.transform.position = aux.worldPosition;
            }
        }*/

        if(Vector3.Distance(simulatedArm(robotState), goal.transform.position) < 0.07f) {
            if(pathQueue.Count != 0) {
                Node aux = pathQueue.Dequeue();
                goal.transform.position = aux.worldPosition;
            }
        }

        switch(whichFitness){
            case 1:
                fitnessEvaluation4();
                break;

            case 2:
                fitnessEvaluation5();
                break;

            case 3:
                fitnessEvaluation2();
                break;

            case 4:
                fitnessEvaluation1();
                break;

            case 5:
                fitnessEvaluation3();
                    break;

            default:
                break;
        }

        if(UIScript.isCollectingData){
            totalSumDistanceDestination[generation-1] += Vector3.Distance(finalPosition.position, simulatedArm(robotState));
            totalSumDistanceObstacleRobot[generation-1] += distanceObstacles(robotState);
            totalSumDistanceObstacleReal[generation-1] += (float)((gridScript.layers - closestNodeToObstacle(robotState).layer) * gridScript.nodeDiameter);

            /*for(int counter=0; counter<N; counter++){
                
                differenceAngles[counter, generation-1] += Mathf.Abs(robotState[counter] - previousRobotState[counter]);
            }*/
        }

        updateObject();
        newPopulation();
        checkObstacles();

        //Mudança Fog of War
        if(isShowingFog){
            checkHiddenObstacles();
        }

        //previousRobotState = robotState;
        //prints the generation and best fitness, i intend to make this to be written into a text file for another program to read and plot
        if(maxGenerations != -1) {
            //makes the update method stop when a certain number of generations is reached
            //logFile.WriteLine(generation + ", " + previousBestfitness + ", " + distanceObstacles(robotState));
            if(generation >= maxGenerations) {
                //writes data to the file and closes it
                //endProgram();
                if(UIScript.isCollectingData && UIScript.getSimulationCounter() < 49){

                    this.enabled = false;
                    UIScript.setSimulationCounter(-1);
                    UIScript.resetSimulationWithObstacles();

                } else{

                    for(int counter=0; counter<2300; counter++){

                        totalSumDistanceDestination[counter] /= 50;
                        totalSumDistanceObstacleReal[counter] /= 50;
                        totalSumDistanceObstacleRobot[counter] /= 50;

                        logFile.WriteLine(totalSumDistanceDestination[counter] + ". " + totalSumDistanceObstacleReal[counter] + ". "+ 
                                        totalSumDistanceObstacleRobot[counter] +". " + counter + ". " + whichFitness);
                        
                        /*for(int counter2=0; counter2<N; counter2++){

                            differenceAngles[counter2, counter] /= 50;
                        }

                        logFile.WriteLine(differenceAngles[0, counter] + ". " + differenceAngles[1, counter] + ". " + differenceAngles[2, counter] 
                                        + ". " + differenceAngles[3, counter] + ". " + differenceAngles[4, counter]);*/
                    }
                    
                    logFile.Flush();

                    totalSumDistanceDestination = new float[2300];
                    totalSumDistanceObstacleReal = new float[2300];
                    totalSumDistanceObstacleRobot = new float[2300];
                    //differenceAngles = new float[N, 2300];
                    whichFitness +=1;

                    if (whichFitness>3){
                        endProgram();
                    }

                    UIScript.setSimulationCounter(0);
                    this.enabled = false;
                    UIScript.resetSimulationWithObstacles();
                }
            }
        }
        generation++;
    }

    public void updateObject(){

        Quaternion rotation = Quaternion.identity;
        Vector3 position = robot.transform.GetChild(0).position; // base of first segment

        for(int counter=0; counter<N; counter++){

            // Get the joint rotation (Euler -> Quaternion)
            Quaternion jointRotation = Quaternion.Euler(robotState[counter]);

            // Accumulate the rotation
            rotation *= jointRotation;

            // Set the segment's position and rotation
            armParts[0, counter].transform.position = position;
            armParts[0, counter].transform.rotation = rotation;

            // Compute the position of the next segment's base
            position += rotation * Vector3.up * segmentLength;
        }

        // Set the end effector sphere (at the end of the last segment)
        armParts[2, 0].transform.position = position;

        // Save the current state for future comparison
        previousRobotState = SceneScript.DeepCopy(robotState);
    }

    public void addObstacle(GameObject a) {
        a.transform.hasChanged = false;
        obstaclesList.Add(a);

    }

    /*public void clearObstacles() {

        foreach (var obj in obstaclesList)
        {
            if (obj != null)
            {
                Destroy(obj);
            }
        }
        obstaclesList.Clear();

        //Mudança Fog of War
        obstaclesListFound.Clear();
    }*/

    public void clearObstacles()
    {
        foreach (var obstacle in obstaclesList)
        {
            if (obstacle != null)
            {   
                obstacle.GetComponent<Renderer>().material.color = Color.white;
                obstacle.SetActive(false);
            }
        }
        obstaclesList.Clear();

        // Mudança Fog of War
        obstaclesListFound.Clear();
    }
    
    void checkObstacles() {//checks if an obstacle has moved
        foreach(GameObject obstacle in obstaclesList) {
            if (obstacle.transform.hasChanged == true) {
                if(obstacle.GetComponent<CheckMovement>().isMoving == false) {
                    gridScript.RecreateGrid(obstacle);

                    //Mudança Fog of War
                    if(obstaclesListFound.Contains(obstacle)){
                        robotGridScript.RecreateGrid(obstacle);
                    }

                    //gridScript.createGrid();
                    obstacle.transform.hasChanged = false;
                }
            }
        }
    }

    //Mudança Fog of War
    void checkHiddenObstacles(){
        
        Node closestNode = closestNodeToObstacle(robotState);

        if(closestNode!=null && gridScript.layers - closestNode.layer <= 0){
            
            Collider[] colliders = Physics.OverlapSphere(closestNode.worldPosition, gridScript.nodeDiameter, gridScript.unwalkableMask);
            foreach (Collider col in colliders){
                
                if(!obstaclesListFound.Contains(col.gameObject)){
                    
                    List<Vector3> auxList = new List<Vector3>();
                    foreach (Node n in pathQueue){
                        auxList.Add(new Vector3(n.gridX, n.gridY, n.gridZ));
                    }

                    obstaclesListFound.Add(col.gameObject);
                    robotGridScript.AddObstacleToGrid(col.gameObject);
                    col.gameObject.GetComponent<Renderer>().material.color = Color.red;

                    Node[,,] auxGrid = robotGridScript.grid;
                    foreach (Vector3 n in auxList){

                        if(!auxGrid[(int)n.x, (int)n.y, (int)n.z].walkable){
                            
                            Node currentNode = robotGridScript.NodeFromWorldPoint(goal.transform.position);
                            int index = robotGridScript.path.FindIndex(n => n.worldPosition == currentNode.worldPosition);

                            Node newNode = currentNode;
                            while(!newNode.walkable){

                                index -= 1;
                                Node auxNode = robotGridScript.path[index];
                                newNode = auxGrid[auxNode.gridX, auxNode.gridY, auxNode.gridZ];
                            }
                            astarScript.ChangePath(newNode.worldPosition);
                            /*dstarScript.MoveAndUpdate(newNode.worldPosition, col.gameObject);
                            createPathQueue();*/
                            break;
                        }
                    }
                }
            }
        }
    }

    void endProgram() {
        sw.Stop();
        logFile.WriteLine("/------------------------------------------------/");
        logFile.WriteLine("Time elapsed(ms): " + sw.ElapsedMilliseconds);
        logFile.WriteLine("Generations: " + maxGenerations);
        logFile.WriteLine("Number of joints: " + N);
        logFile.WriteLine("Population size: " + popSize);
        logFile.WriteLine("MaxStep: " + maxStep);
        logFile.WriteLine("Generations per objective: " + generationsPerObjective);
        logFile.WriteLine("Segment lenght: " + segmentLength);
        logFile.Dispose();
        Application.Quit();
        this.enabled = false;
    }

    void fitnessEvaluation1() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float distAux = distanceObstacles(robotState);//calculated only once, as this is the most CPU expensive element of the calculation
        float bestFitness;
        bool considerObstacles = false;
        if(distAux < segmentLength) {
            bestFitness = 1/Vector3.Distance(simulatedArm(robotState), goal.transform.position) + distAux + distanceObstaclesFromPoint(simulatedArm(robotState))/10; //simplified the calculation and have unlimited both parts of the fitness calculation
            considerObstacles = true;
        }
        else
            bestFitness = 1/Vector3.Distance(simulatedArm(robotState), goal.transform.position);
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            //calculated the fitness, or distance to the goal
            float fitness;
            //calculated only once, as this is the most CPU expensive element of the calculation 
            if(considerObstacles){
                float distAux2 = distanceObstacles(popStates[i]);
                
                fitness = 1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position) + distAux2 + distanceObstaclesFromPoint(simulatedArm(popStates[i]))/10; // also considering the tip of the arm, but in a lower cost
            }
            else
                fitness = 1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position);
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    void fitnessEvaluation2() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float bestFitness = Mathf.Min(1/Vector3.Distance(simulatedArm(robotState), goal.transform.position), 10/SceneScript.distJoints) - 1/Mathf.Pow(distanceObstacles(robotState), 2); //a if that doesnt require the square root to be calculated
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            //calculated the fitness, or distance to the goal
            
            float fitness = Mathf.Min(1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position), 10/SceneScript.distJoints) - 1/Mathf.Pow(distanceObstacles(popStates[i]), 2);
            /*print(Mathf.Min(1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position), 10/GetComponent<CreateScene>().distJoints));
            print(1/Mathf.Pow(distanceObstacles(popStates[i]), 2));*/
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    void fitnessEvaluation3() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float valueAux;
        float dist = distanceObstacles(robotState);
        if(dist < 0){

            valueAux = 0;
        } else {

            valueAux = Mathf.Sqrt(dist);
        }

        float bestFitness = Mathf.Min(1/Vector3.Distance(simulatedArm(robotState), goal.transform.position), 4/SceneScript.distJoints) + Mathf.Min(SceneScript.distJoints, valueAux);
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            //calculated the fitness, or distance to the goal

            dist = distanceObstacles(popStates[i]);
            if(dist < 0){

                valueAux = 0;
            } else {

                valueAux = Mathf.Sqrt(dist);
            }
            
            float fitness = Mathf.Min(1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position), 4/SceneScript.distJoints) + Mathf.Min(SceneScript.distJoints, valueAux);
            //checks if its better and saves its configuration
            
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    void fitnessEvaluation4() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float auxObstacles = distanceObstacles(robotState);
        float bestFitness = 1/Vector3.Distance(simulatedArm(robotState), goal.transform.position) + 1*(auxObstacles <= 0 ? -Mathf.Infinity : auxObstacles);
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            //calculated the fitness, or distance to the goal
            auxObstacles = distanceObstacles(popStates[i]);
            float fitness = 1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position) + 1*(auxObstacles <= 0 ? -Mathf.Infinity : auxObstacles);
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    void fitnessEvaluation5() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        float bestFitness = -Vector3.Distance(simulatedArm(robotState), goal.transform.position) + distanceObstacles(robotState);

        for (int i = 0; i < popSize; i++){
            float fitness = -Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position) + distanceObstacles(popStates[i]);
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<Vector3>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    //Modo Fog of War
    float distanceObstaclesFromPointRobot(Vector3 point) {
        Node place = robotGridScript.NodeFromWorldPoint(point);

        return (gridScript.layers - place.layer) * gridScript.nodeDiameter;
    }

    float distanceObstacles(List<Vector3> angles) {
        //Mudança Fog of War
        //if(obstaclesListFound.Count == 0) return 0; //a 0 value means no obstacle exists and thus it shouldn't be considered
        
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;
        //the distance will be the minimum distance to an obstacle
        float distance = 999999;
        for (int j = 0; j < N; j++) {

            Quaternion jointRotation = Quaternion.Euler(angles[j]);

            // Update the cumulative rotation (parent-to-child)
            rotation *= jointRotation;
            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis

            float minDistanceCurrentJoint;
            //Mudança Fog of War
            if(isShowingFog){

                minDistanceCurrentJoint = distanceObstaclesFromPointRobot(position);
            } else {

                minDistanceCurrentJoint = distanceObstaclesFromPoint(position);
            }

            //compares to see if it is any smaller than the closest distance yet
            distance = Mathf.Min(minDistanceCurrentJoint, distance);
        }

        return distance;
    }

    float distanceObstaclesFromPoint(Vector3 point) {
        Node place = gridScript.NodeFromWorldPoint(point);

        return (gridScript.layers - place.layer) * gridScript.nodeDiameter;
    }

    //Mudança Fog of War
    Node closestNodeToObstacle(List<Vector3> angles) {
        if(obstaclesList.Count == 0) return null; //a 0 value means no obstacle exists and thus it shouldn't be considered
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;
        //the distance will be the minimum distance to an obstacle
        float distance = 999999;
        Node closestNode = null;
        for (int j = 0; j < N; j++) {

            Quaternion jointRotation = Quaternion.Euler(angles[j]);

            // Update the cumulative rotation (parent-to-child)
            rotation *= jointRotation;
            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis
            float minDistanceCurrentJoint = distanceObstaclesFromPoint(position);

            //compares to see if it is any smaller than the closest distance yet
            //distance = Mathf.Min(minDistanceCurrentJoint, distance);
            if(distance >= minDistanceCurrentJoint){

                distance = minDistanceCurrentJoint;
                closestNode = gridScript.NodeFromWorldPoint(position);
            }
        }

        return closestNode;
    }

    //does the math to calculate the end position given a set of angles
    Vector3 simulatedArm(List<Vector3> evaluated) {
        //the position starts at the base position
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;
    
        for (int j = 0; j < N; j++) {

            Quaternion jointRotation = Quaternion.Euler(evaluated[j]);

            // Update the cumulative rotation (parent-to-child)
            rotation *= jointRotation;

            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis
        }

        // Return the calculated end effector position
        return position;
    }

    void newPopulation(){
        // Generate new population
        if(generation % 100 == 0) {
            mutRate = Mathf.Max((mutRate + 1) % N, 1);//the mutation keeps changing every 100 generations and it means the number of joint that are gonna be changed
        }
        for (int i = 0; i < popSize; i++){
            for (int j = 0; j < mutRate; j++){
                int idx = Random.Range(0, N);//a random index is generated
                float angleX = Random.Range(-maxStep + robotState[idx].x, maxStep + robotState[idx].x);
                float angleY = Random.Range(-maxStep + robotState[idx].y, maxStep + robotState[idx].y);
                float angleZ = Random.Range(-maxStep + robotState[idx].z, maxStep + robotState[idx].z);
                popStates[i][idx] = new Vector3(angleX, angleY, angleZ);
            }
        }
    }

    public float[] getUIData() {

        float elapsedMilliseconds = (sw != null) ? (float)sw.ElapsedMilliseconds : -1;

        return new float[]
        {
            elapsedMilliseconds, 
            (float)maxGenerations, 
            (float)N, 
            (float)popSize, 
            maxStep, 
            //(float)generationsPerObjective, 
            segmentLength,
            (float)((gridScript.layers - closestNodeToObstacle(robotState).layer) * gridScript.nodeDiameter),
            distanceObstacles(robotState)
        };
    }

    public void setFogOfWar(bool value){

        isShowingFog = value;
    }
}